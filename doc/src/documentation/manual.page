---
title: Manual
---

## The `webgen` command


The executable for webgen is called... webgen ;-) It uses a command style syntax (like Subversion's
`svn` or Rubygem's `gem` commands) through the [cmdparse] library. To get an overview of the
possible commands run `webgen help`.

TODO: implement missing commands mentioned in the following paragraphs

webgen supports many commands, from checking the validity of the configuration and the available
libraries to displaying the configuration values. The main command is the `run` command which does
the actual website generation. This command uses the current working directory as website directory
if none was specified via the gloabl `-d` option.

You can invoke a command by specifying its name after the executable name. Also counting the
executable `webgen` as a command, the options for a command are specified directly after the command
name and before the next command or any arguments. For example, all the following command lines are
valid:

    $ webgen
    $ webgen run
    $ webgen -d doc run
    $ webgen -V 0 create -t project
    $ webgen about config
    $ webgen help create

For detailed information on how the individual commands work have a their documentation in the
(TODO:link) plugin documentation section. Following is a short overview of the available commands:

*   `about`

    This command displays detailed information about installed plugins and their parameters

*   `apply_style`

    This command is used to apply a style to a website. It is most often used to apply a different
    default website style to a website.

*   `bundle`

    This command is used for managing webgen plugin bundles which are used for extending webgen with
    functionality or resources. It provides several sub commands for doing the actual work all of
    which should be pretty self explanatory. To get started first use the `update` and then the
    `list` command.

*   `create`

    Creates a basic webgen website using an (optionally specified) template and style.

*   `check`

    Checks the configuration file for validness and checks the loadability of all plugins.

*   `help`

    Displays usage information. Can be used to show information about a command by using the command
    name as argument, eg. `webgen help bundle` or `webgen help bundle list`.

*   `run`

    Runs webgen and generates the output.

*   `version`

    Displays the version of webgen.



[cmdparse]: http://cmdparse.rubyforge.org



## File Handling ##   {#filehandling}


### File Types

webgen can handle many different types of files in the source directory through its plugin
concept. The file handler plugins are used for this task.

The most important files are the page and template files as they are used to define the content and
the layout of your website. Have a look at the WebPage Format documentation to see how these files
look like and how they are structured. After that have a look at the documentation for the plugins
File/PageHandler and File/TemplateHandler as they are responsible for handling the page and template
files!

You can naturally use any other type of file in the webgen source directory. However, be aware that
some files may not be processed by webgen when no file handler plugin for them exist. For example,
there is currently no file handler plugin for `.svg` files, so those files would be ignored. If you
just want to have files copied from the source to the output directory (like images or CSS files),
the File/CopyHandler plugin is what you need! Look through the availabe file handler plugins to get
a feeling what files are handled by webgen.

### Path Patterns {#pathpattern}

Each file handler plugin specifies path patterns which are used to locate the files that the plugin
can handle. Normally these patterns are used to match file extensions, however, they are much more
powerful. For detailed information have a look at the
[Dir.glob](http://ruby-doc.org/core/classes/Dir.html#M002375) API documentation.

The path patterns that are handled by a particular file handler plugin are stated on its
documentation page and cannot be changed for most plugins, eg. the File/PageHandler will always
handle `.page` files. However, the information about how these path patterns work are useful for the
usage of webgen because of two reasons:

* so that you know which files will be processed by a specific file handler plugin

* so that you can specify path patterns for some special file handler plugins that support
  additional path patterns, like the File/CopyHandler.

Here are some example path patterns:

<table class="examples" markdown='1'>
<tr><th>Path Pattern</th><th>Result</th></tr>
<tr>
  <td>`*/*.html`</td>
  <td>All files with the extension `html` in the subdirectories of the source directory</td>
</tr>
<tr>
  <td>`**/*.html`</td>
  <td>All files with the extension `html` in all directories</td>
</tr>
<tr>
  <td>`**/{foo,bar}*`</td>
  <td>All files in all directories which start with `foo` or `bar`</td>
</tr>
<tr>
  <td>`**/???`</td>
  <td>All files in all directories whose file name is exactly three characters long</td>
</tr>
</table>

### Handling of files in the source directory {#filehandling-source}

Following is the list of rules how files in the source directory are handled by webgen:

* All file/directory names in the source directory are fetched (actually, only those file/directory
  names without a leading dot).

* Those files which match an Core/FileHandler:ignorePaths pattern are excluded.

* The path patterns for each file handler plugin are matched against the remaining files and all
  matching files are then handled by the file handler plugin.

As you might have deduced from the processing list above, it is possible that one file/directory is
handled by multiple file handler plugins. This can be used, for example, to render an XML file as
HTML and copy it verbatim.

Internally a tree structure is created reflecting the source directory hierarchy and each file that
is handled by webgen. The following image shows how files in the source directory are related to the
generated files in the output directory:

> The name used for describing a directory or file once it is placed in the internal tree structure
> is 'node'.
{.information}

<img src="{relocatable: /images/node_diagram.png}" alt="Internal tree structure" />

The source directory layout is shown on the left side and the output layout on the right. As you can
see, some files are copied verbatim (e.g. the images), others are copied not all
(e.g. `default.template`) and still others have multiple output files (e.g.
`project/documentation.page`).

After this internal tree structure is created, it is traversed and each node is processed. First the
node is checked if has changed (the notion of 'changed' depends on the file handler plugin for this
node but a node has changed, for example, if its meta information or the associated source file has
changed since the last webgen run). If it has not changed, nothing needs to be written. Otherwise,
the information needed to write out the node is gathered and the rendered content (depends on the
file handler plugin, too) is written to the output file represented by the node.

--> add information about how directories are handled and provide a link to File/DirectoryHandler for more information

### Source File Naming Convention ### {#filehandling-naming}

webgen assumes that the files in the source directory follow a special naming convention sothat meta
information can be extracted correctly from the filename:

    [orderInfo.]basename[.lang].extension

*   `orderInfo`

    This part is optional and has to consist purely of the digits 0 to 9. Its value is used for the
    meta information `orderInfo`. If not specified, it defaults to the value zero.

*   `basename`

    This part is used on the one hand to generate the `title` meta information (but with `_` and `-`
    replaced by spaces). And on the other hand, the canonical name is derived from it. `basename`
    must not contain any dots, spaces or any character from the following list: ``; / ? * : ` & = +
    $ ,``. If you do use one of them webgen may not work correctly! Also: if two files have the same
    `basename` part, they should define the same content but for different languages.

*   `lang`

    This part is optional and has to be an [ISO-639-1/2](http://www.loc.gov/standards/iso639-2/)
    language identifier (two or three characters (a-z) long). If not specified, it is assumed that
    the page is language independent (for example, images are normally not specific for a specific
    language). However, this behaviour may be different for some file handler plugins (for example,
    the File/PageHandler assumes that the file is written in the default language set via the
    Core/Configuration:lang parameter).

    If the language identifier can't be matched to a valid language, it is assumed that this part
    isn't actually a language identifier but a part of the extension. This also means that in the
    special case where the first part of an extension is also a valid language identifier, the first
    part is interpreted as language identifier and not as part of the extension.

*   `extension`

    The file extension can be anything and can include dots.

Following are some examples of source file names:

|Filename                  | Parsed meta information
|--------------------------|------------------------------------------------
|`name.png`                | title: Name, language: none, orderInfo: 0, basename: name, cn: name.png
|`name.de.png`             | title: Name, language: de, orderInfo: 0, basename: name, cn: name.png
|`01.name_of-file.eo.page` | title: Name of file, language: eo, orderInfo: 1, basename: name_of-file, cn: name_of-file.page
|`name.tar.bz2`            | title: Name, language: none, orderInfo: 0, basename: name, cn: name.tar.bz2
|`name.de.tar.bz2`         | title: Name, language: de, orderInfo: 0, basename: name, cn: name.tar.bz2

Notice: The first two and the last two examples define the same content for two different languages
(or more exactly: the first one is unlocalized and the second one localized to German) as they have
the same canonical name.

### Canonical Name of a File ### {#filehandling-cn}

webgen provides the functionality to define the same content in more than one language, ie. to
localize content. This is achieved with the _canonical name_ of a file.

When multiple files share the same canonical name, webgen assumes that they have the same content
but in different languages. It is also possible to specify a _language independent_ file which is
used as a fallback. Therefore when a file should be resolved using a canonical name and a given
language, it is first tried to get the file in the requested language. If this is not possible
(ie. no such localization exists), the unlocalized file is returned if it exists.

It is also possible to use the _localized canonical name_ of a file to resolve it. The localized
canonical name is the same as the canonical name but with a language code inserted before the
extension. If the localized canonical name is used to resolve a file, a possibly additionally
specified language is ignored as it is assumed that the user really only wants the file in the
specified language!

This also means that all files are not resolved using their real source or output names but using
the (localized) canonical name! This is different from previous webgen versions!

### Output File Naming ### {#filehandling-output}

The output filename for a given source filename is constructed using the
File/DefaultHandler:outputNameStyle parameter which can be individually (for a specific file handler
plugin or a file) overwritten by using the meta information `outputNameStyle`. This parameter is an
array which can have the following values:

* strings (for inserting arbitrary text into output names)
* arrays (for grouping values - only interesting for the language part)
* symbols for inserting special values:
  * `:basename`: the basename of the file
  * `:lang`: the language
  * `:ext`: the file extension including the leading dot

Following are some examples of output file names for given source file names (assuming that `en` is
the default language):

*   `outputNameStyle=[:basename, [., :lang], :ext]` (the default)

    *   `index.jpg` --> `index.jpg`

        Since the source file is unlocalized, no language part is used and the whole sub array with
        the `:lang` symbol is dropped.

    *   `index.en.jpg` --> `index.jpg`

        This happens if File/DefaultHandler:defaultLangInOutputName is false and no unlocalized
        version of this file exists.

    *   `index.en.jpg` --> `index.en.jpg`

        Similar to the last example but this result occurs when there is an unlocalized version of
        the file which is naturally named `index.jpg`!

    *   `index.de.jpg` --> `index.de.jpg`

        Since `de` is not the default language, the language part is always used!

*   `outputNameStyle=[:basename, :ext, ., :lang]`

    *   `index.jpg` --> `index.jpg.`

        Be aware of the trailing dot since the `:lang` value is not defined in an sub array.


## The Configuration File


## File Meta Information {#metainfo}


Each file can have meta information, i.e. information about the file itself, associated with it, for
example the title of the file, if it should appear in a menu and so on. This meta information can be
specified in several ways, including:

* File handlers can provide default meta information for their handled files (which can be
  overridden using Core/FileHandler:defaultMetaInfo parameter).

* Some file types allow meta information to be specified directly in the file, for example page
  files.

* Meta information can also be specified in the [meta information backing file](#metainfo-file).

### The `defaultMetaInfo` parameter ### {#metainfo-param}

This parameter can be used to override the default meta information set for a file handler plugin.
The keys are the names of file handler plugins and the values are the meta information. You can
either set the parameter directly or use a special functionality provided by the configuration file
(TODO: still to write) to set it for a file handler plugin.

### The meta information backing file ### {#metainfo-file}

The meta information backing file contains meta information about files/directories in the source
directory. It has two sections both of which have to be in YAML format and both have to have the
same structure: a source backing section and an output backing section which is optional. The
sections are separated by three dashes on an otherwise empty line.

The source backing section is used to apply meta information to a file before a node for this file
is created. A file handler plugin can therefore use this meta information during the creation of the
node. Make sure that you use a valid source path, i.e. a path that resolves to a file in the source
directory!

The output backing section is used to apply meta information after _all_ nodes have been created and
to create so called "virtual nodes". The paths specified in the output backing section have to be:

* valid (localized) canonical names (for assigning meta info to existing nodes) or
* a path pattern for matching against localized canonical names (for assigning meta info to multiple
  existing nodes)
* the desired output names (for creating virtual nodes)!

The different cases are handled like this:

* If a path has a `*` or a `?` in it, it is considered a path pattern and the meta information is
  assigned to all nodes whose localized canonical name matches the pattern.

  > Since the localized canonical name of the nodes are used, you need to remember that the pattern
  > `**/*.html` sets the meta information on all nodes ending in `.html` whereas the pattern
  > `**/*.en.html` only sets the meta information on English nodes ending in `.html.
  {.information}

* If a specified path resolves to an already created node, the meta information is applied to this
  node.

* If the path ends in an slash, a directory node is created with the meta information.

* Otherwise, a virtual node is created with the specified meta information and empty content - a
  virtual node _never_ creates a real output file!

This facility can be used, for example, to specify meta information common to a set of nodes (for
example, the author of blog pages), to include links to external web pages in menus or to create a
whole menu with custom sections and multiple references in different sections to the same node!

Following is a sample meta information backing file with explanations afterwards:

    index.page:
      inMenu: true
      orderInfo: 2

    images:
      indexFile: ~
    ---
    index.html:
      inMenu: false

    wiki.html:
      title: Link to wiki
      url: http://myhost.com/path/to/my/wiki
      inMenu: true
      orderInfo: 5

    api.html:
      title: API Reference
      url: http://myhost.com/api

    virtdir/:
      indexFile: index.html

    virtdir/index.html:
      title: A virtual index file
      inMenu: true
      url: /index.page

    virtdir/other.html:
      inMenu: true
      url: /otherdir/linked.de.page

    **/*.html:
      author: The Real Author

The above sample meta information backing file consists of both sections: the mandatory source
section and the optional output section. As you can see each section is described using a hash of
hashes, i.e. the keys are paths and the values are the meta information hashes.

The source section specifies additional meta information for the `index.page` file and for the
`images` directory: the `index.page` gets the `inMenu` and `orderInfo` meta information set and it
is specified that the `images` directory has no `indexFile`.

The output section is more interesting than the source section:

* The first entry references an existing file, therefore the meta information for that file
  (`index.html`) is set appropriately.

* The second entry specifies that under the `root` directory a virtual node with the path
  `wiki.html` should be created (the node will be virtual as the path references no existing file).
  It should have the specified title and should be in the menu with the specified
  order. Furthermore, a special *`url`* key is used. This key can only be used for virtual file
  nodes (not directory nodes) in the output section and it specifies the link target for the node.
  So, whenever a reference to `wiki.html` is requested the resolved `url` is returned. This `url`
  can be a link to an outside page or it can refer to another node, as described below. The `url` is
  assumed to be relative to the directory the virtual node is in.

* The third entry also specifies a virtual node linking to an external page, but one which will not
  appear in a menu. Such nodes are normally inserted into the output section so that the
  Tag/Relocatable plugin can be used.

* The next three entries add virtual entries to the menu to show how one page can appear in more
  than one directory: the `virtdir/index.html` links to the top level `index.page` and
  `virtdir/other.html` links to a page in another subdirectory, namely `/otherdir/linked.de.page`.

* The last entry set the `author` meta information on all nodes that end with `.html`.

### Processing order ### {#metainfo-processing}

There is clearly defined order in which meta information is applied to a node for a file:

1. The default meta information for a node is specified via a directive in the plugin file handler
   that creates the node (this means that it is possible that no default meta information is
   specified). If such a default meta information is set for a plugin file handler it is shown on
   its plugin documentation page.

2. Overridden by values that are set for the plugin file handler for the node in the
   Core/FileHandler:defaultMetaInfo parameter.

3. Overridden by the meta information extracted from the filename.

4. Overridden by the meta information specified for the file in the source backing section of the
   meta information backing file.

5. Now the node is created by the file handler plugin with this meta information. During the node
   creation, it is possible that the meta information is overridden by meta information extracted
   from the file by the file handler plugin (e.g. the File/PageHandler uses the meta information
   specified in the file itself).

6. After all nodes are created, meta information specified in the output backing section of the meta
   file backing file is applied.


## Extending webgen

If you the programming language Ruby a little bit, you can easily extend webgen and add new features
that you need. All the developer documentation is in the RDoc API (TODO: link) documentation, along
with sample plugins for all types of plugins (file handler plugins, tag plugins, content processor
plugins, ...)  and detailed information about the inner workings of webgen.

### Creating plugin/resource bundles

TODO: provide link to API doc, explain different types of plugins available, how resources can be
added and provide short example

### Making bundles available

TODO: create own repository which gets added to master repo list, or send created package + info to me
