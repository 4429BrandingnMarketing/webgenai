---
title: Documentation
inMenu: true
orderInfo: 30
---

# Getting Started With webgen


## Tutorial: Creating a Basic Website


### Creating the Basic Directories

webgen needs a special directory structure so that it works correctly. Basically, you have a website
directory under which the following directories are:

* `src`: The source directory in which all the source files for the website are. The name of this
  directory cannot be changed!

* `output`: This directory is created, if it does not exist, when webgen generates the HTML
  files. All the output files are put into this directory. The name of this directory and its
  location can be customized using the parameter Core/Configuration:outDir.

* `plugins`: The extension directory (optional). You can put self-written plugin bundles into this
  directory so that they can be used by webgen.

The directory in which these directories are in is called the *website directory*.

Don't worry too much about these directories since webgen is able to create the correct directory
structure for you. By running the command `webgen create sample_site`, the website directory
`sample_site` is created with the default website template and website style. You can naturally use
any available template or style by passing their names to the respective options of the `create`
command.

> A *website template* provides a starting point for your website. For example, the `project`
> template defines several pages including a features and about page.
>
> A *website style* defines the look and feel of your website. webgen comes with many predefined
> styles (nearly all of them are converted open source web design styles).
{.information}

------------------- TODO -------------------------
You can also change the website style later by using the `use website_style` command for `webgen`, for
example:

    $ webgen use website_style default

Existing files may be overwritten by this command (after asking). However, this command is not able
to delete previously copied website style files, so you have to remove them yourself!

Have a look at the examples sections (TODO:linke) to see demonstrations for all shipped website
templates and styles!
------------------- TODO -------------------------

Since the basic parts are now in place, you can generate the HTML files. There are two
possibilities:

* Either you change into the `sample_site` directory and run the command `webgen`.

* Or you run webgen from any directory and specify the website directory using the `-d` option, for
  example `webgen -d sample_site`.

Easy! webgen has parsed the `src` directory and has created the HTML output. However, as we did not
write any content yet, there is not much to see (only the default pages). So let's do that now!

### Adding Content

TODO: describe marukp languages (markdown, textile, rdoc), default markup language

------------------- TODO -------------------------
Meta information is specified at the beginning of a page file. Have a look at the WebPage Format
reference to see how that is done in detail!
------------------- TODO -------------------------

When using the `create` command, webgen does not only create the needed directories but it also
provides you with some default files, you will have at least the following ones:

* `src/default.template`: The default template for the new website.
* `src/default.css`: The default css file for the new website.
* `src/index.page`: The index page for the root directory of the website.

> *Template files* and *page files* are the heart of webgen. Template files are used to define a
> general layout for web pages and page files define the real content. Both file types are written
> in WebPage Format.
{.information}

The basic scaffolding is already in place. Now we only have to adapt the page file `index.page` and
add other page files. Open the file `index.page` in your favorite text editor and change its
content. After that create a new file, `hello.page`, in the source directory with the following
content:

    ---
    title: Sample hello page
    inMenu: true
    ---
    This is a sample page with the title "{title:}" and it is in the menu!!!

Then run webgen again and open `output/index.html` to view your changes. Add page files and other
content to your website and let it grow!

### Adding Dynamic Content

TODO: describe ways of adding dynamic content (tags, erb)

------------------- TODO -------------------------
Using Tags and Meta Information in Pages
------------------- TODO -------------------------

We are now going to use meta information to customize our website. Open the file `default.template`
and add this before the `</body>` tag:

    File last changed on \{filemdate: }!

The part `\{filemdate: }` is called a tag. Tags are implemented using plugins and they can be used
to insert dynamic content when webgen is run. For example, a menu can be generated with the
`\{verticalMenu: }` tag. If webgen sees a tag during the processing of a page for which no tag
plugin exists, it looks at the meta information of the page. If there is a meta information entry
with the tag name, it uses that content instead. We will use this behaviour now.

Open the file `hello.page` and add the following meta information:

    filemdate: 10.4.2005

so that `hello.page` looks like this:

    ---
    title: Sample hello page
    inMenu: true
    filemdate: 10.4.2005
    ---
    This is a sample page with the title "{title:}" and it is in the menu!!!

Run webgen and view the output! The tag `\{filemdate: }` got substituted by the value specified in
the meta information. As we have not put any meta information in the `index.page` file, a warning is
displayed when webgen is run and no date is shown on the page!

### Changing Plugin Parameters

webgen provides a default configuration out of the box. If you can live with that, you do not need
to write anything to the configuration file. However, most users need to change some configuration
setting sometime. The configuration file is called `config.yaml` and has to be placed directly under
the website directory. It has to be written in YAML format.

Most plugins define parameters which can be configured through the configuration file. You can
display a list of all available parameters by running `webgen about -p` (TODO: has to be implemented)

> This information is also provided on this website, have a look at the TODO:ref Plugin parameter
> reference! You can alternatively look at a plugin documentation page when you want to get
> parameter information from one plugin only.
{.information}

The list shows sorted by the plugin name the current values and the default values for each
parameter. Each parameter can be overridden in the configuration file by specifing the plugin name
as top level key and each parameter and value as a key/value pair. A sample configuration file
looks like this:

    File/CopyHandler:
      paths: ["**/*.css", "**/*.js", "**/*.jpg", "**/*.png", "**/*.gif", "**/*.zip"]

    Misc/SmileyReplacer:
      emoticonPack: crystal

TODO: check plugin names before release

TODO: add extra section for configuration file

------------------- TODO -------------------------
There is a special key for file handler plugins: `defaultMetaInfo`. It's value should be a hash with
the default meta information for nodes created by the plugin. The value is used to update the
correct part of the Core/FileHandler:defaultMetaInfo parameter *if and only if* no value
for the Core/FileHandler:defaultMetaInfo parameter has been set in the configuration file!
------------------- TODO -------------------------



# In-Depth Documentation


## The `webgen` command


The executable for webgen is called... webgen ;-) It uses a command style syntax (like Subversion's
`svn` or Rubygem's `gem` commands) through the [cmdparse] library. To get an overview of the
possible commands run `webgen help`.

TODO: implement missing commands mentioned in the following paragraphs

webgen supports many commands, from checking the validity of the configuration and the available
libraries to displaying the configuration values. The main command is the `run` command which does
the actual website generation. This command uses the current working directory as website directory
if none was specified via the gloabl `-d` option.

You can invoke a command by specifying its name after the executable name. Also counting the
executable `webgen` as a command, the options for a command are specified directly after the command
name and before the next command or any arguments. For example, all the following command lines are
valid:

    $ webgen
    $ webgen run
    $ webgen -d doc run
    $ webgen -V 0 create -t project
    $ webgen about config
    $ webgen help create

For detailed information on how the individual commands work have a their documentation in the
(TODO:link) plugin documentation section. Following is a short overview of the available commands:

*   `about`

    This command displays detailed information about installed plugins and their parameters

*   `apply_style`

    This command is used to apply a style to a website. It is most often used to apply a different
    default website style to a website.

*   `bundle`

    This command is used for managing webgen plugin bundles which are used for extending webgen with
    functionality or resources. It provides several sub commands for doing the actual work all of
    which should be pretty self explanatory. To get started first use the `update` and then the
    `list` command.

*   `create`

    Creates a basic webgen website using an (optionally specified) template and style.

*   `help`

    Displays usage information. Can be used to show information about a command by using the command
    name as argument, eg. `webgen help bundle` or `webgen help bundle list`.

*   `run`

    Runs webgen and generates the output.

*   `version`

    Displays the version of webgen.



[cmdparse]: http://cmdparse.rubyforge.org



## File Handling ##   {#filehandling}


### File Types

webgen can handle many different types of files in the source directory through its plugin
concept. The file handler plugins are used for this task.

The most important files are the page and template files as they are used to define the content and
the layout of your website. Have a look at the WebPage Format documentation to see how these files
look like and how they are structured. After that have a look at the documentation for the plugins
File/PageHandler and File/TemplateHandler as they are responsible for handling the page and template
files!

You can naturally use any other type of file in the webgen source directory. However, be aware that
some files may not be processed by webgen when no file handler plugin for them exist. For example,
there is currently no file handler plugin for `.svg` files, so those files would be ignored. If you
just want to have files copied from the source to the output directory (like images or CSS files),
the File/CopyHandler plugin is what you need! Look through the availabe file handler plugins to get
a feeling what files are handled by webgen.

### Path Patterns {#pathpattern}

Each file handler plugin specifies path patterns which are used to locate the files that the plugin
can handle. Normally these patterns are used to match file extensions, however, they are much more
powerful. For detailed information have a look at the
[Dir.glob](http://ruby-doc.org/core/classes/Dir.html#M002375) API documentation.

The path patterns that are handled by a particular file handler plugin are stated on its
documentation page and cannot be changed for most plugins, eg. the File/PageHandler will always
handle `.page` files. However, the information about how these path patterns work are useful for the
usage of webgen because of two reasons:

* so that you know which files will be processed by a specific file handler plugin

* so that you can specify path patterns for some special file handler plugins that support
  additional path patterns, like the File/CopyHandler.

Here are some example path patterns:

<table class="examples" markdown='1'>
<tr><th>Path Pattern</th><th>Result</th></tr>
<tr>
  <td>`*/*.html`</td>
  <td>All files with the extension `html` in the subdirectories of the source directory</td>
</tr>
<tr>
  <td>`**/*.html`</td>
  <td>All files with the extension `html` in all directories</td>
</tr>
<tr>
  <td>`**/{foo,bar}*`</td>
  <td>All files in all directories which start with `foo` or `bar`</td>
</tr>
<tr>
  <td>`**/???`</td>
  <td>All files in all directories whose file name is exactly three characters long</td>
</tr>
</table>

### Handling of files in the source directory {#filehandling}

Following is the list of rules how files in the source directory are handled by webgen:

* All file/directory names in the source directory are fetched (actually, only those file/directory
  names without a leading dot).

* Those files which match an Core/FileHandler:ignorePaths pattern are excluded.

* The path patterns for each file handler plugin are matched against the remaining files and all
  matching files are then handled by the file handler plugin.

As you might have deduced from the processing list above, it is possible that one file/directory is
handled by multiple file handler plugins. This can be used, for example, to render an XML file as
HTML and copy it verbatim.

Internally a tree structure is created reflecting the source directory hierarchy and each file that
is handled by webgen. The following image shows how files in the source directory are related to the
generated files in the output directory:

> The name used for describing a directory or file once it is placed in the internal tree structure
> is 'node'.
{.information}

<img src="{relocatable: /images/node_diagram.png}" alt="Internal tree structure" />

The source directory layout is shown on the left side and the output layout on the right. As you can
see, some files are copied verbatim (e.g. the images), others are copied not all
(e.g. `default.template`) and still others have multiple output files (e.g.
`project/documentation.page`).

After this internal tree structure is created, it is traversed and each node is processed. First the
node is checked if has changed (the notion of 'changed' depends on the file handler plugin for this
node but a node has changed, for example, if its meta information or the associated source file has
changed since the last webgen run). If it has not changed, nothing needs to be written. Otherwise,
the information needed to write out the node is gathered and the rendered content (depends on the
file handler plugin, too) is written to the output file represented by the node.

--> add information about how directories are handled and provide a link to File/DirectoryHandler for more information

### Source File Naming Convention ### {#filehandling-source}

webgen assumes that the files in the source directory follow a special naming convention sothat meta
information can be extracted correctly from the filename:

    [orderInfo.]basename[.lang].extension

*   `orderInfo`

    This part is optional and has to consist purely of the digits 0 to 9. Its value is used for the
    meta information `orderInfo`. If not specified, it defaults to the value zero.

*   `basename`

    This part is used on the one hand to generate the `title` meta information (but with `_` and `-`
    replaced by spaces). And on the other hand, the canonical name is derived from it. `basename`
    must not contain any dots or any character from the following list: ``; / ? : ` & = + $ ,``. If
    you do use one of them webgen may not work correctly! Also: if two files have the same
    `basename` part, they should define the same content but for different languages.

*   `lang`

    This part is optional and has to be an [ISO-639-1/2](http://www.loc.gov/standards/iso639-2/)
    language identifier (two or three characters (a-z) long). If not specified, it is assumed that
    the page is language independent (for example, images are normally not specific for a specific
    language). However, this behaviour may be different for some file handler plugins (for example,
    the File/PageHandler assumes that the file is written in the default language set via the
    Core/Configuration:lang parameter).

    If the language identifier can't be matched to a valid language, it is assumed that this part
    isn't actually a language identifier but a part of the extension. This also means that in the
    special case where the first part of an extension is also a valid language identifier, the first
    part is interpreted as language identifier and not as part of the extension.

*   `extension`

    The file extension can be anything and can include dots.

Following are some examples of source file names:

|Filename                  | Parsed meta information
|--------------------------|------------------------------------------------
|`name.png`                | title: Name, language: none, orderInfo: 0, basename: name, cn: name.png
|`name.de.png`             | title: Name, language: de, orderInfo: 0, basename: name, cn: name.png
|`01.name_of-file.eo.page` | title: Name of file, language: eo, orderInfo: 1, basename: name_of-file, cn: name_of-file.page
|`name.tar.bz2`            | title: Name, language: none, orderInfo: 0, basename: name, cn: name.tar.bz2
|`name.de.tar.bz2`         | title: Name, language: de, orderInfo: 0, basename: name, cn: name.tar.bz2

Notice: The first two and the last two examples define the same content for two different languages
(or more exactly: the first one is unlocalized and the second one localized to German) as they have
the same canonical name.

### Canonical Name of a File ### {#filehandling-cn}

webgen provides the functionality to define the same content in more than one language, ie. to
localize content. This is achieved with the _canonical name_ of a file.

When multiple files share the same canonical name, webgen assumes that they have the same content
but in different languages. It is also possible to specify a _language independent_ file which is
used as a fallback. Therefore when a file should be resolved using a canonical name and a given
language, it is first tried to get the file in the requested language. If this is not possible
(ie. no such localization exists), the unlocalized file is returned if it exists.

It is also possible to use the _localized canonical name_ of a file to resolve it. The localized
canonical name is the same as the canonical name but with a language code inserted before the
extension. If the localized canonical name is used to resolve a file, a possibly additionally
specified language is ignored as it is assumed that the user really only wants the file in the
specified language!

This also means that all files are not resolved using their real source or output names but using
the (localized) canonical name! This is different from previous webgen versions!

### Output File Naming ### {#filehandling-output}

The output filename for a given source filename is constructed using the
File/DefaultHandler:outputNameStyle parameter which can be individually (for a specific file handler
plugin or a file) overwritten by using the meta information `outputNameStyle`. This parameter is an
array which can have the following values:

* strings (for inserting arbitrary text into output names)
* arrays (for grouping values - only interesting for the language part)
* symbols for inserting special values:
  * `:basename`: the basename of the file
  * `:lang`: the language
  * `:ext`: the file extension including the leading dot

Following are some examples of output file names for given source file names (assuming that `en` is
the default language):

*   `outputNameStyle=[:basename, [., :lang], :ext]` (the default)

    *   `index.jpg` --> `index.jpg`

        Since the source file is unlocalized, no language part is used and the whole sub array with
        the `:lang` symbol is dropped.

    *   `index.en.jpg` --> `index.jpg`

        This happens if File/DefaultHandler:defaultLangInOutputName is false and no unlocalized
        version of this file exists.

    *   `index.en.jpg` --> `index.en.jpg`

        Similar to the last example but this result occurs when there is an unlocalized version of
        the file which is naturally named `index.jpg`!

    *   `index.de.jpg` --> `index.de.jpg`

        Since `de` is not the default language, the language part is always used!

*   `outputNameStyle=[:basename, :ext, ., :lang]`

    *   `index.jpg` --> `index.jpg.`

        Be aware of the trailing dot since the `:lang` value is not defined in an sub array.


## The Configuration File


## File Meta Information {#metainfo}


Each file can have meta information, i.e. information about the file itself, associated with it, for
example the title of the file, if it should appear in a menu and so on. This meta information can be
specified in several ways, including:

* File handlers can provide default meta information for their handled files (which can be
  overridden using Core/FileHandler:defaultMetaInfo parameter).

* Some file types allow meta information to be specified directly in the file, for example page
  files.

* Meta information can also be specified in the [meta information backing file](#metainfo-file).

### The `defaultMetaInfo` parameter ### {#metainfo-param}

This parameter can be used to override the default meta information set for a file handler plugin.
The keys are the names of file handler plugins and the values are the meta information. You can
either set the parameter directly or use a special functionality provided by the configuration file
(TODO: still to write) to set it for a file handler plugin.

### The meta information backing file ### {#metainfo-file}

The meta information backing file contains meta information about files/directories in the source
directory. It has two sections both of which have to be in YAML format and both have to have the
same structure: a source backing section and an output backing section which is optional. The
sections are separated by three dashes on an otherwise empty line.

The source backing section is used to apply meta information to a file before a node for this file
is created. A file handler plugin can therefore use this meta information during the creation of the
node. Make sure that you use a valid source path, i.e. a path that resolves to a file in the source
directory!

The output backing section is used to apply meta information after _all_ nodes have been created and
to create so called "virtual nodes". The paths specified in the output backing section have to be
valid (localized) canonical names (for assigning meta info to existing nodes) or the desired output
names (for creating virtual nodes)! There are three different cases:

* If a specified path resolves to an already created node, the meta information is applied to this
  node.

* If the path ends in an slash, a directory node is created with the meta information.

* Otherwise, a virtual node is created with the specified meta information and empty content - a
  virtual node _never_ creates a real output file!

This facility can be used, for example, to include links to external web pages in menus or to create
a whole menu with custom sections and multiple references in different sections to the same node!

Following is a sample meta information backing file with explanations afterwards:

    index.page:
      inMenu: true
      orderInfo: 2

    images:
      indexFile: ~
    ---
    index.page:
      inMenu: false

    wiki.html:
      title: Link to wiki
      url: http://myhost.com/path/to/my/wiki
      inMenu: true
      orderInfo: 5

    api.html:
      title: API Reference
      url: http://myhost.com/api

    virtdir/:
      indexFile: index.html

    virtdir/index.html:
      title: A virtual index file
      inMenu: true
      url: /index.page

    virtdir/other.html:
      inMenu: true
      url: /otherdir/linked.de.page

The above sample meta information backing file consists of both sections: the mandatory source
section and the optional output section. As you can see each section is described using a hash of
hashes, i.e. the keys are paths and the values are the meta information hashes.

The source section specifies additional meta information for the `index.page` file and for the
`images` directory: the `index.page` gets the `inMenu` and `orderInfo` meta information set and it
is specified that the `images` directory has no `indexFile`.

The output section is more interesting than the source section:

* The first entry references an existing file, therefore the meta information for that file
  (`index.page`) is set appropriately.

* The second entry specifies that under the `root` directory a virtual node with the path
  `wiki.html` should be created (the node will be virtual as the path references no existing file).
  It should have the specified title and should be in the menu with the specified
  order. Furthermore, a special *`url`* key is used. This key can only be used for virtual file
  nodes (not directory nodes) in the output section and it specifies the link target for the node.
  So, whenever a reference to `wiki.html` is requested the resolved `url` is returned. This `url`
  can be a link to an outside page or it can refer to another node, as described below. The `url` is
  assumed to be relative to the directory the virtual node is in.

* The third entry also specifies a virtual node linking to an external page, but one which will not
  appear in a menu. Such nodes are normally inserted into the output section so that the
  Tag/Relocatable plugin can be used.

* The last three entries add virtual entries to the menu to show how one page can appear in more
  than one directory: the `virtdir/index.html` links to the top level `index.page` and
  `virtdir/other.html` links to a page in another subdirectory, namely `/otherdir/linked.de.page`.

### Processing order ### {#metainfo-processing}

There is clearly defined order in which meta information is applied to a node for a file:

1. The default meta information for a node is specified via a directive in the plugin file handler
   that creates the node (this means that it is possible that no default meta information is
   specified). If such a default meta information is set for a plugin file handler it is shown on
   its plugin documentation page.

2. Overridden by values that are set for the plugin file handler for the node in the
   Core/FileHandler:defaultMetaInfo parameter.

3. Overridden by the meta information extracted from the filename.

4. Overridden by the meta information specified for the file in the source backing section of the
   meta information backing file.

5. Now the node is created by the file handler plugin with this meta information. During the node
   creation, it is possible that the meta information is overridden by meta information extracted
   from the file by the file handler plugin (e.g. the File/PageHandler uses the meta information
   specified in the file itself).

6. After all nodes are created, meta information specified in the output backing section of the meta
   file backing file is applied.


## Extending webgen

If you the programming language Ruby a little bit, you can easily extend webgen and add new features
that you need. All the developer documentation is in the RDoc API (TODO: link) documentation, along
with sample plugins for all types of plugins (file handler plugins, tag plugins, content processor
plugins, ...)  and detailed information about the inner workings of webgen.

### Creating plugin/resource bundles

TODO: provide link to API doc, explain different types of plugins available, how resources can be
added and provide short example

### Making bundles available

TODO: create own repository which gets added to master repo list, or send created package + info to me

# How to ...


This section provides quick answers and links for the most commonly asked questions. If you click on
any question, the answer will appear just below it.

TODO: Use JQuery to add a toggle link to all Howto titles
TODO: categorize questions

### ... chain templates?

TODO

### ... create a website?

Use the `webgen` command to create the needed directories

    webgen create -t project -s andreas07 my_site

This will create a webgen website in the directory `my_site` using the specified template and style.

### ... use a website/gallery/sipttra style?

TODO: rework answer after use command is implemented
Just use the `webgen` command line tool:

    webgen use website_style STYLE_NAME
    webgen use gallery_style STYLE_NAME
    webgen use sipttra_style STYLE_NAME

Be aware that destination files may be overwritten!

### ... set plugin parameters?

You can set plugin parameters for all plugins via the configuration file. For example, say you want
to set the File/DefaultHandler:linkToCurrentPage parameter to `true`, then you would add
the following to the configuration file:

    File/DefaultHandler:
      linkToCurrentPage: true

There is a second possibility for tags: you can set the parameters directly in the tag definition,
like this:

    \{breadcrumbTrail: {omitLast: true, separator: ' | '}}

### ... change the default language?

To use, for example, German as the default language, put the following into the configuration file:

    Core/Configuration:
      lang: de

The value needs to be a valid ISO-639-1/2 language code.

### ... use a different processing pipeline for page files?

If you want to change the processing pipeline, you need to add the following to your configuration
file (assuming you didn't manually set the Core/FileHandler:defaultMetaInfo parameter):

    File/PageHandler:
      defaultMetaInfo:
        blocks:
          default:
            pipeline: erb;tags;textile;blocks

Substitute the value of the `pipeline` key approriately.

If you just want to change the pipeline for one block, you can do it like this:

    --- content, pipeline:erb;tags;textile;blocks
    This is the content of the block

### ... set the default meta information for files created by a specific file handler?

Use the configuration file! For example, to change the meta information `inMenu` sothat it defaults
to `true` for all page files use the following in your configuration file:

    File/PageHandler:
      defaultMetaInfo:
       inMenu: true

The special key `defaultMetaInfo` is available for all file handler plugins in the configuration
file.

### ... ignore files in the source directory?

This can be done using the Core/FileHandler:ignorePaths parameter. For example, to ignore all files
starting with `core`, you would put the following in the configuration file:

    Core/FileHandler:
      ignorePaths: [**/core*]

The value of the `ignorePaths` key has to be an array of path patterns (TODO:link). Be aware that
the parameter overwrites the default setting.

### ... change the output name style?

You have several options of varying granularity:

* Set the File/DefaultHandler:outputNameStyle parameter in the configuration file to globally change
  how the output names for files are constructed.

* Add the meta information `outputNameStyle` to the `defaultMetaInfo` of a specific file handler
  plugin in the configuration file to only change the output names of this file handler.

* Apply the meta information `outputNameStyle` to a single file via, for example, the meta
  information backing file (TODO:link).

For more information have a look at the documentation of the File/PageHandler:outputNameStyle
parameter!

### ... use embedded ruby in page/template files?

TODO: rework this answer
Have a look at the ERB section of the WebPage Format reference!

### ... modify the template chain?

First, have a look at the File/TemplateHandler documentation!

To stop the template chain at a specific template or even at the page file itself, specify a
null template in the meta information, like this:

    template: ~

To nest templates, you just need to specify the template, in which this template/page file should be
nested, in the meta information:

    template: my_special.template

Be aware that if no `template` meta information is specified for a page or template file, the
template handler automatically searches for a default template in the directory and the parent
directories of the file!

### ... localize a directory name?

Just set the `directoryName` meta information on the localized directory index files.

### ... provide additional attributes on links to a file?

You can specify additional attributes for a link to a file by using the `linkAttrs` meta
information. Take the following page file:

    ---
    title: Tutorial
    inMenu: true
    linkAttrs:
      title: This is a rather large tutorial
      accesskey: D
      tabindex: 5
    ---
    Yippieh, this is my tutorial!

When a link to this page is created the specified attributes get set on the link!

### ... add page specific sidebar content?

There are many ways to accomplish this, I will show only one way here using blocks. Add the
following to the sidebar in your `default.template` (ensure that you haven't disabled `erb` in the
processing pipeline):

    <% if node.node_info[:page].blocks.has_key?( 'sidebar' ) %>
      \{block: sidebar}
    <% end %>

This will include the contents of the block `sidebar` in the sidebar if such a block exists for a
page. You can then add a sidebar block to each page file which needs it. Following is such a sample
page file:

    This is the main content block
    --- sidebar
    This is the sidebar block and everything in here goes to the sidebar!


### ... use global variables?

TODO: check answer after copying/implementing the Tag/CustomVar plugin
First you need to set some global variables in your configuration file:

    Core/Configuration:
      customVars:
        myVar: This is really nice!
        myOtherVar: another content

Then you can use the Tag/CustomVar to output the variables:

    \{customVar: myVar}

### ... create XML output?

TODO: check this answer after implementing ContentProcessor/Builder

This can be achieved manually (by removing any markup processor in the processing pipeline of the
page file and then directly creating the XML elements) or by changing the processing pipeline to
include the ContentProcessor/Builder plugin which provides an easy way of creating an XML compliant
file.

### ... use emoticons instead of ASCII smileys?

TODO: check this answer after implementing the SmileyProcessor

Either globally enable an emoticon pack in the configuration file, like this:

    Misc/SmileyReplacer:
      emoticonPack: crystal

Or enable smiley replacement only on a specific page file using the meta information, like this:

    emoticonPack: crystal

### ... syntax highlight an included file?

TODO: rework this because now it is possible to specify a tag body

------------------- TODO -------------------------

This can be done using the Tag/IncludeFile plugin. Make sure you have `coderay` installed! Here is
an example which includes a syntax highlighted ruby file:

  \{includeFile: {filename: happy.rb, highlight: ruby}}
------------------- TODO -------------------------

### ... create a static menu?

You can use virtual nodes in the output backing section of the meta information backing file to
define virtually any menu structure you like, including things like having menu entries that point
to the same page and links to external pages.

For detailed information have a look at the meta information backing file (TODO:link) documentation!


### ... create a website template/style?

This is described in the API documentation for the Support/WebsiteManager plugin (TOOD:link).



# References



## Meta Information Reference


TODO: use CSS :before and :after selectors to add Type:/Example:/...
TODO: update infos of all entries

Following is a list of all the meta information items that are used in one way or another by a
plugin, be it a file handler plugin, a tag plugin or any other plugin. Each meta information
description follows the same pattern:

* First the type of value and an example value are listed.
* Then the paths for which this item is valid are listed.
* And at last follows a detailed description.

{:miref: .meta-information-ref}

### blocks

{:miref}
* Array of Arrays: `[[content, markdown], [sidebar, html]]`
* Page/Template files

Sets the name and format of content blocks. Each sub-array contains, in this order, the name of the
block and its format.

### directoryName

{:miref}
* String: `Image Directory`
* Any

Only used if set on a directory index file; specifies the title of the directory for which it is the
index file. If it is not specified, the title of the directory will be used.

### emoticonPack

{:miref}
* String: `bigeyes`
* Page files

Sets the emoticon package which should be used for the page.

### indexFile

{:miref}
* String: `getting.page`
* Directories

Sets the directory index file for the directory overriding the default value.

### inMenu

{:miref}
* Boolean: `true`
* Any

Specifies if the file/directory should appear in menus.

### lang

{:miref}
* String: `de`
* Page files

Sets the language for the page file. Has to be a valid ISO-639-1/2 character code for the language.

### linkAttrs

{:miref}
* Hash: `\{title: Hallo, class: extra}`
* Any

Specifies additional attribute-value pairs (in form of a Hash) that should be added to a link to the
file/directory.

### link\_callback

{:miref}
* String (Ruby code):`"<a#{attrs}>#{link_text} + some text</a>"`
* Any

Can be used to customize the link generated for the node. The available variables are:

node
: The node to which the link points.

ref\_node
: The reference node.

attrs
: A string of compiled HTML attributes that should be on the link element.

link\_text
: The text for the link.

context
: An optional hash with context information. The key :caller is set to the plugin which invoked the
  link generation, e.g. MenuStyle/Vertical or Tag/Langbar. Optional other key-value pairs are
  provided depending on the plugin.

### omitIndexFileInBreadcrumbTrail

{:miref}
* Boolean: `false`
* Index files

Controls whether the index file should appear in a breadcrumb trail despite the setting of the
Tag/BreadcrumbTrail:omitIndexFile parameter.

### orderInfo

{:miref}
* Integer: `15`
* Any

Sets the ordering information for the file/directory. The value 0 is used as default and means 'not
set'.  You should only use numbers greater than zero. However, if you want a menu item to always
appear as first item, it is recommended to use the value -1. When sorting nodes, the `orderInfo`
value is used first. If the values for both compared nodes are the same, then they are sorted
according to their `title` meta information.

### outputNameStyle

{:miref}
* String: `[:name, [".", :lang], ".html"]`
* Page files

Sets a custom output name style for the specified page file only. The basename is substituted for
the value `:name` and the language for the value `:lang`. Strings are used verbatim. If `:lang` is
specified in a sub-array, the whole sub-array is omitted, if the parameter
File/PageHandler:defaultLangInFilename is false.

### template

{:miref}
* String: `my.template`
* Page/Template files

Sets the template for the page/template file overriding the default value. If set to `nil`, no
template is used for the page/template file!

### title

{:miref}
* String: `New Title`
* Any

Sets the title for the file/directory.



## Resource Reference



The following list shows all resources that are shipped with webgen and that can be used via the
Tag/Resource plugin.

*Credits*:

* webgen-icons-\*: These icons were taken from the
  [CrystalClear](http://www.kde-look.org/content/show.php?content=25668) package
* webgen-emoticons-\*: Credits for the individual emoticon packs are listed on the Misc/SmileyReplacer page

\{predefinedResources:} TODO: copy this plugin from trunk and adjust it


## Plugin Parameter Reference


Each plugin can specify parameters. Here is a list of all available parameters for a quick lookup,
ordered by category and then name (only plugins with parameters are shown!):

\{listPluginParameters:} TODO: copy this plugin from trunk and adjust it


## WebPage Format


The WebPage Format is a custom format designed primarily for page and template files. It consists of
an optional meta information block and one or more blocks of data; it is very simple and easy to
use.

### Structure

A file using the WebPage Format consists of one or more blocks which are the smallest units
recongnized. Blocks are separated from each other through a line containing only three dashes. This
is illustrated in the following examples which are all valid files in WebPage Format:

TODO: make sure each example gets its own pre block

    Here is a block!


    This is one block of the file
    ---
    This is another block.


    Block 1
    --- block2
    Block 2
    --- block3
    Block 3...

If you want to use three dashes in a block but you don't want to end the block, you have to escape
them with a backslash character, like this:

    Block 1
    \---
    still Block 1
    --- block2
    Block 2

All of the above examples show one kind of block, the content block. However, there may also be
another type of block: the meta information block. Following is a short description of both kinds,
starting with the meta information block.

#### Meta Information Block

Each file in WebPage Format can have zero or one meta information blocks. This block is specified at
the beginning of the file. To tell the parser that the first block is the meta information block and
not a content block, you have to start the file with three dashes:

    ---
    title: The title set by Meta info
    ---
    This is the content of the file

The above defines a meta information block and a content block. The meta information block has to be
in YAML format and should contain key-value pairs of meta information. [YAML](http://www.yaml.org)
is a simple markup language designed for ease of use and although you define structured data with
it, it feels like just writing a plain text document.

#### Content Blocks

TODO: redo this section since the structure of content blocks has changed since 0.4.x

A content block is used to provide content in a specific format. Each file in WebPage Format needs
to have at least one content block which may be empty. However, it can have as many content blocks
as necessary. Each content block needs to have a unique name and a format specifier.

The name uniquely identifies a content block and is used to access it. The format specifier defines
in which format the content block was written. The important thing is that all the formats can be
converted into HTML/XML! There are several different formats available - have a look a the
ContentConverter section.

There may also be defaults for the two identifiers but they can be overwritten. There are two ways
to do this:

* you either specify the name and format of the block on the line with the three dashes
* or you use the special meta information block to define the names and formats of all blocks.

The following example uses the first technique to override the name and/or the format:

    1. content block of the file
    --- sidebar, markdown
    2. content block of the file
    --- other
    3. content block of the file

The first block has no identifieres set (there is no line with three dashes and the identifieres).
Therefore the default values for both are used: `content` is the default block name and `default` is
the default format specifier. However, these defaults can be overridden by the plugins.

The second block is named `sidebar` and uses the format `markdown`. As you see, first the name of
the block is specified and then, separated by a comma, the format specifier. The format identifier
can be omitted as shown for the third block, the default value is then used.

You can also set the name and format of the content blocks by using the special `blocks` meta
information. It is an array of arrays and each sub-array contains, in this order, the name of the
block and its format. The above example can therefore also be written like this:

    ---
    blocks: [[content,default], [sidebar, markdown], [other, ~]]
    ---
    1. content block of the file
    ---
    2. content block of the file
    ---
    3. content block of the file


With everything said above the example should be clear except maybe for the last sub-array. The
first entry specifies the name, `other`, and the second the format, `~`. The tilde has a special
meaning in YAML format, namely null or empty. This means that we want to use the default format for
the last block.

The *default name* for a block is `content` and is used if no explicit name is given on the line
with the three dashes or in the blocks meta information at the correct index. The precedence is
(from high to low): --- line, blocks meta information, default value.

The *default format* for a block is `default` and the rules stated above for the block name apply to
the default format as well.


### webgen Tags

TODO: remove this whole section since it depends on the processing pipeline??? or add a special
section explaining the processing pipeline. ev. move this to the docu for the tags processor. or
still better move this to its own reference section since this is a special webgen construct

Tags are used to generate content. During processing of a file in WebPage Format so called 'tags'
are replaced with dynamic content. For example, the menu you can see to the left was generated by a
tag. This makes it easier to add or remove menu items. If the menu was not generated, you would have
to change every file which uses the menu.

#### Usage

Tags are defined by a special markup code. A tag has the following structure:

    \{tagname: {parameters}}

Every time a tag is found in a file, the registered plugin for the tag is called. The plugin returns
a string which is put into the output file instead of the tag. The output a tag plugin can produce
ranges from something simple to something complex. For example, the Tag/Meta plugin copies any
additional meta information specified in the file verbatim into the correct place in the output
file. And in contrast, the Tag/Menu plugin generates a whole menu tree.

If you want to use the markup code used for tags, you need to escape the tag with a backslash, like
this:

    \\\{tagname: {parameters}}

#### Parameters

A tag can have zero or more parameters some of which are mandatory. You can see the supported
parameters (and if they are mandatory) for each tag on the tag's plugin page. The default mandatory
parameter can be specified in a special way, see the examples below. The format used for parsing the
parameters is YAML.

Here some examples with tags and parameters:

<table class="examples">
<tr>
  <th>Usage</th><th>Output</th>
</tr>
<tr>
  <td>`\{tagname: }`</td>
  <td>No parameters specified</td>
</tr>
<tr>
  <td>`\{tagname: test.html}`</td>
  <td>The default mandatory parameter is set to `test.html`. This form can only be used if there is only one mandatory parameter</td>
</tr>
<tr>
  <td>`\{tagname: {param1: value1, param2: value2}}`</td>
  <td>Two parameters (param1 and param2) specified</td>
</tr>
</table>


### Processing

TODO: redo this whole section

There is a well defined procesing order for files in WebPage Format:

* After reading in the file, it is split into the blocks.

* Each content block is converted to HTML (depends on the format specifier) and the HTML sections
  are resolved (caveat: only those with an `id` attribute)

* When writing out the file, the converted content is first processed with ERB (if specified to do
  so),

* then webgen tags are replaced and,

* finally, the result is written.

The first two steps happen when the file is read and the last three when the file is written.

#### Converting to HTML

The conversion of a content block to HTML is done via the ContentConverter plugins. Each plugin is
able to convert a special marked-up text to HTML.

#### Evaluating ERB Tags

TODO: ev move this to the ContentProcessor/Erb documentation???

The evaluation of ERB (embedded ruby) tags is optional and only done if the meta information
`useERB` is set to `true`. The use of ERB allows to add dynamic content without using webgen tags.
Following is an example of a file which uses ERB:

<notextile>
<pre>
\---
title: Test page with ERB
useERB: true
\---
This page has the following meta info items:
&lt;% node.meta_info.each do |key, value| %&gt;
    * &lt;%=key %&gt;: &lt;%=value %&gt;
&lt;% end %&gt;
</pre>
</notextile>

This would output all meta information for the file. There are some objects available which you can
use in your ERB code:

* `node`: the node for the current file (normally a page file)
* `ref_node`: the reference node, i.e. the node in which the content will be embedded (normally a
  template file)

*Caveat*: you may need to ensure that the ERB start and end tags are not processed by the content
converter. For example, with Textile you may need to surround the ERB code with &lt;textile&gt;
tags!

#### Evaluating webgen Tags

Tags have already been mentioned in the webgen tags (TODO:link) section.



## Sipptra File Format



### What is sipptra?

sipttra is the acronym for **S**imple **P**lain **T**ext **T**racker. It is a ticket tracker which
stores everything inside a human readable text file. Therefore it can be used with any text editor
and no additional program for editing is needed.

sipttra supports categories with different types, a special milestone category and, naturally,
tickets.

As everything is stored in a text file, sipttra is not intended to be used by many concurrent users.
It is a simple and easy system for one-man-projects as well as small projects with not many
developers.

### Types

sipttra is line and not character based. This means that it only operates on whole lines and each
line can have a different type. This section describes the available types and the next section
explains how these types can be used in a sipttra file.

#### Categories

A category has a name and a type which have to be unique among all categories. Therefore it is not
possible to define two equal category lines in one sipttra file. Tickets can only be defined for
categories. The category type further distinquishes the tickets of a category name. For example,
normally you have at least open bugs and closed bugs. For sipttra, this means that you have defined
a category named bugs with type open and another category named bugs with type closed.

A category is defined like this:

    ### CATEGORY (type) ###

or this:

    # CATEGORY (type) #

The line has to start with one or more hashes, the category name, the category type and finally the
same number of hashes as at the start of the line. These items have to be separated from each other
by spaces.

The tickets of a category are of the same type as the category itself. The special type `closed`
signifies that the tickets in the category are closed, tickets from all other category types are
considered to be open.

#### Milestone Category

The milestone category is defined like a normal category. However, the type in parenthesis is
omitted, like this:

    ### Milestones ###

A sipttra file can contain exactly one such milestone category! This is the only distinction between
normal categories and the milestone category.


#### Tickets

Tickets are defined like this:

    * NAME (YYYY-MM-DD) [BELONGS_TO] summary
      further description

      still in the description

Basically all parts are optional. However, if no summary is specified it is assumed to be empty. The
name uniquely distinguishes the ticket among all tickets independent of the category. The date in
parenthesis is considered to be the due date, ie. the date on which this ticket should be closed.
The 'belongs to' part in square brackets defines a relationship to another ticket. The summary part
is a short description of the ticket. All following lines which are either empty or indented exactly
two spaces belong to the detailed description of the ticket (one can use Markdown syntax in the
detailed description). *Caveats*: if one wants to only specify a name and a summary for a ticket,
these two parts have to be separated by a colon sothat the parser can distinguish them. Also be
aware that the spaces between the individual parts are mandatory!

Here are some examples for valid tickets:

    * name1: summary

    * name2 (2007-02-15) my summary here

    * name3 [othername] yeah, this also works
      with additional description

      which still belongs to ticket name3

Two important attributes for tickets are defined indirectly:

* status: The status is defined by the category type to which a ticket belongs
* priority: The priorites of the tickets are defined by their order. The ticket defined first in a
  category has the highest priority, the last defined ticket the lowest.

Tickets for the milestone category are defined like normal tickets. However, milestone tickets must
have a name!

#### Comments

Comment lines are allowed everywhere in a sipttra file! Each line which is neither a category line,
a ticket line or a line belonging to an additional description of a ticket becomes a comment line.
Also be aware that if a line for a ticket or category is not well structured, it automatically
becomes a comment line.

### The sipttra File Format

A sipttra file starts with an optional meta information part. If you want to have a meta information
part the sipttra file has to start with three dashes on the first line. Everything till the next
line with three dashes is considered to be meta information. This meta information part has to be
valid YAML.

The main part consists of the tracker definition. It is read line by line from top to bottom:

* All lines before the first category line are considered to be comment lines.
* Tickets always belong to the last defined category.
* The same category can not be defined twice in one sipttra file!

### Examples

Here are some example sipttra files.

Example one:

    ---
    webgen-metainfo:
      inMenu: true
      title: Project Status
    ---

    ### Milestones ###

    * Feb07 (2007-02-28) Bug fixes and small enhancements
      - add support for sipttra files, the Simple Plain Text Tracker

    * F: Ideas and todo items for future versions

    Here could be some potential comment! :)

    ### Features (open) ###

    * T002 [F] another ticket
      this is additional text

    ### Features (closed) ###

    * T003 [F] and another closed ticket

Example two:

    This are just some
    comment lines
    here!

    ### Milestones ###

    * Feb07 (2007-02-28) Bug fixes and small enhancements

    Here could be some potential comment! :)

    ### Features (open) ###

    * T001 [Feb07] one ticket

    * T002 [Feb07] another ticket
      this is additional text

    ### Features (closed) ###

    * T003 [Feb07] and another closed ticket

    ### Bugs (open) ###

    * T008 [Feb07] you should really close this bug!

    ### Bugs (closed) ###

    * T009 [Feb07] yeah, very cool, a closed bug!

Example three:

    ### Features (open) ###

    * T001 [Feb07] one ticket

    * T002 [F] another ticket
      this is additional text


    ### Features (closed) ###

    * T003 [F] and another closed ticket



## Plugin Documentation



TODO: Provide general information about plugins, how the plugin docu is structured and a link to the
top of the plugin documentation tree



--------- Still to add somewhere

desribe processing pipeline (maybe best in WebPage Format reference)

--------- Copied documentation


